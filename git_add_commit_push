#!/usr/bin/env bash

#The current iteration of the script allows you to commit and push files in a local repository to a remote repository on GitHub. The script accepts three command-line options:
#
#-d: The directory to look for files. By default, the script looks in the current directory (.).
#-t: The file type extension. This option allows you to specify a file type, and the script will commit all files with that extension in the specified directory.
#-r: A regular expression pattern. This option allows you to specify a regular expression pattern, and the script will commit all files that match that pattern in the specified directory.
#When the script is run, it first initializes three variables: directory, file_type, and regex_pattern to default values.
#
#Then, it uses the getopts command to parse the command-line options passed to the script. The script uses a while loop to iterate through the options passed to the script. The case statement is used to check the option passed to the script, and the value of that option is assigned to the corresponding variable.
#
#Once the options are parsed, the script uses the find command to search for files in the specified directory that match the specified file type or regular expression pattern. The find command is used with the -type f option to search for only files, not directories.
#
#If any files are found, the script uses the git add command to stage the files for commit. It then generates a commit message that includes the current date and time, as well as a summary of the files that are being committed. The summary is generated by using the tr command to replace spaces with newlines, then using the xargs command to pass the filenames one at a time to the basename command, which is used to strip the directory path from the filenames. The resulting list of filenames is then concatenated into a single string and truncated to 58 characters
#
#Use case 1: Commit all files in the current directory
#
#$ ./myscript.sh
#
#Use case 2: Commit all .txt files in the current directory
#
#$ ./myscript.sh -t txt
#
#Use case 3: Commit all files in the directory /path/to/my/folder
#
#$ ./myscript.sh -d /path/to/my/folder
#
#Use case 4: Commit all files with the pattern "myfile*" in the current directory
#
#$ ./myscript.sh -r "myfile*"
#
#Use case 5: Commit all .txt files in the directory /path/to/my/folder
#
#$ ./myscript.sh -d /path/to/my/folder -t txt
#
#Use case 6: Commit all files with the pattern "myfile*" in the directory /path/to/my/folder
#
#$ ./myscript.sh -d /path/to/my/folder -r "myfile*"
#
#Note: The above use cases are examples and not all the possible variations. You can use the script in any combination of the options to achieve your desired results.


#-------------Script Starting Point---------------------

directory="./"
file_type=""
regex_pattern=""

while getopts "d:t:r:" opt; do
  case $opt in
    d) directory="$OPTARG" ;;
    t) file_type="$OPTARG" ;;
    r) regex_pattern="$OPTARG" ;;
  esac
done

current_time=$(date +"%Y-%m-%d %T")

if [ -z "$file_type" ] && [ -z "$regex_pattern" ]; then
    files=$(find "$directory" -type f)
elif [ -z "$regex_pattern" ]; then
    files=$(find "$directory" -name "*.$file_type" -type f)
else
    files=$(find "$directory" -regex "$regex_pattern" -type f)
fi

if [ -n "$files" ]; then
    git add $files
    summary=$(echo $files | tr ' ' '\n' | xargs -n1 basename | tr '\n' ' ' | cut -c 1-58)
    commit_message="$current_time - $summary"
    git commit -m "$commit_message"
    git push
    echo "Commit message: $commit_message"
    echo "Committed and pushed the following files:"
    echo "$files"
else
    echo "No files found to commit and push."
fi
